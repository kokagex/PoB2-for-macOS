LuaJITを使用されているとのこと、より深層（低レイヤー）の原因が見えてきました。
Intel macOS上でLuaJITを動かす際、特に画面表示に関わるトラブルは**「メモリアドレスの衝突」か「FFI経由のネイティブ描画呼び出しの型不一致」**に集約されることが多いです。
Difyのシステム構築と同様、まずは「安定性」を確保するための主要なチェックポイントを挙げます。
1. 致命的な「2GBメモリ制限」とリンクオプション
Intel Mac（x86_64）のLuaJITにおいて最も有名な問題です。LuaJITは内部的に下位4GBのメモリを使用しようとしますが、macOSのカーネルがその領域を先に確保してしまうため、テクスチャデータなどのアロケーションに失敗し、描画が壊れる（あるいは起動直後に落ちる）ことがあります。
 * 症状: 画像が表示されない、テクスチャが化ける、not enough memory エラー。
 * 対策: 実行バイナリのビルド時（またはリンク時）に以下のフラグを立てる必要があります。
   -pagezero_size 10000 -image_base 100000000

   これにより、macOSのメモリ配置をLuaJITが扱える領域から逃がすことができます。
2. FFIによるC関数呼び出しの「型サイズ」の差異
Windows (LLP64) と macOS (LP64) では、C言語の型のサイズが一部異なります。
 * 差異のポイント: * long 型は、Windowsでは 32bit ですが、macOSでは 64bit です。
 * 影響: もし描画ライブラリ（OpenGLや特定のGUIフレームワーク）の引数に long を使っているFFI定義がある場合、スタックがズレて座標計算が崩壊したり、色が正しく渡らなかったりします。
 * 対策: FFIの定義（ffi.cdef）内で long を使わず、int32_t や intptr_t など、サイズが明示的な型に書き換えてください。
3. Cocoa APIとのスレッド競合
macOSの画面描画（UI操作）は、必ずメインスレッドで行う必要があります。
 * 状況: LuaJITからFFI経由でネイティブUIを叩いている場合、Windowsでは通っていた「別スレッドからの描画命令」が、macOSでは無視されたり、表示が更新されなかったりします。
 * 対策: 描画ループがメインスレッドで回っているか、コールバックが適切なスレッドで実行されているか確認してください。
4. Intel GPUのシェーダーコンパイル
Intel Macの内蔵GPUドライバは、シェーダーコードの構文に非常にシビアです。
 * 現象: Windows（NVIDIA/AMD）では動いていたGLSLが、Intel Macではエラーを吐かずに「何も描画しない」状態になる。
 * 確認: LuaJITから glGetShaderInfoLog 等を呼び出し、コンパイルエラーや警告が出ていないかログをダンプしてください。特に implicit cast（floatとintの混在）に厳しいです。
次のステップへの提案
原因を特定するために、以下のどちらの状況に近いか教えていただけますか？
 * 「座標がズレる・サイズがおかしい」
   → Retina対応（BackingStore 係数の考慮）のコード調整が必要です。
 * 「何も表示されない・テクスチャが真っ黒・ノイズが走る」
   → 上記の「2GB制限」か「FFIの型定義ミス」の可能性が高いです。
もし可能であれば、描画部分の ffi.cdef や初期化処理の一部を教えていただければ、macOS向けに修正が必要な箇所を特定します。
