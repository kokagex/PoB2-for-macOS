# テキストレンダリング修正計画 V4

**日付**: 2026-02-02 07:00
**状態**: Phase 3 - 計画立案
**前回の試行**: V1 (dirty flag), V2 (ログ調査), V3 (頂点バッファ検証) - すべて問題なし
**現在の問題領域**: Fragment Shader (テクスチャサンプリング)

---

## V1-V3からの学習統合

### V1: Dirty Flag実装（失敗）

**試行内容**: グリフラスタライズ時にdirty flagセット、end_frame()で一括更新

**結果**: 視覚的変化なし

**学習**: テクスチャ更新タイミングは問題ではない可能性が高い

---

### V2: ロールバック + 詳細ログ調査（完了）

**試行内容**: V1をロールバック、RASTERIZE/DRAWSTRING/DIAG-GLYPHログを追加

**収集データ**: 7,361行のログ

**重要な発見**:
```
RASTERIZE: 全グリフ正常にラスタライズ（48グリフ、すべてアトラス配置成功）
DRAWSTRING: 全文字列正常に処理（7コール、すべて成功）
DIAG-GLYPH-FLUSH: テクスチャ更新正常（フレーム1で1回、フレーム2以降0回 = キャッシュヒット）
```

**結論**: グリフラスタライズ、テクスチャ更新、フラッシュタイミングは**すべて正常**

**学習**: 問題はグリフ生成やテクスチャ更新ではない

---

### V3: 頂点バッファ検証（完了）

**試行内容**: VERTEX-ADD、VERTEX-FLUSHログを追加し、頂点データとUV座標を検証

**収集データ**: 31 MB、546,868 VERTEX-ADD、15,636 VERTEX-FLUSH

**重要な発見**:
```
VERTEX-ADD: すべての頂点データ正常（UV座標、テクスチャポインタ、文字コード）
VERTEX-FLUSH: フラッシュ正常（平均35頂点/フラッシュ）
UV座標: すべてY=0.000（アトラスは単一行レイアウト = 正常）
```

**Sageの分析**:
- 頂点バッファ構造は正常
- UV座標計算は正常（atlas_v0 = 0/512 = 0.000, atlas_v1 = rows/512）
- アトラスレイアウトは設計通り（単一行）

**結論**: 頂点バッファとUV座標は**すべて正常**

**学習**: 問題は頂点レイヤーではない

---

## 問題の絞り込み（Progressive Elimination）

```
[CPU Layer]
  ✅ Lua DrawString() calls          → V2で検証済み
  ✅ グリフラスタライズ                 → V2で検証済み
  ✅ テクスチャ更新                     → V2で検証済み

[GPU Layer - Vertex]
  ✅ 頂点バッファ構築                   → V3で検証済み
  ✅ UV座標計算                        → V3で検証済み
  ✅ テクスチャポインタ                 → V3で検証済み

[GPU Layer - Fragment Shader] ← **未検証、唯一残っている**
  ❓ テクスチャサンプリング
  ❓ アルファブレンディング
  ❓ カラー適用
```

**結論**: Fragment Shaderがテクスチャから正しくサンプリングしていない可能性が最も高い。

---

## V4の根本原因仮説

### 主仮説: Fragment Shader のテクスチャサンプリング問題

**症状の再確認**:
- 行95末尾: "below, the fix works!" （表示される）
- 行109: "Image rendering: (ring.png below)" （表示される）
- 行94: "VISUAL TEST - Metal Fragment Shader Fix" （表示されない）
- 行99-100: "Frame: %d", "Text rendering: WORKING" （表示されない）

**パターン分析**:
1. **同じフォント、同じ色でも一部は表示、一部は非表示**
2. **文字列の後半のみ表示**（行95は末尾のみ、行109は完全表示）
3. **最後に描画されたものは表示される**

### 可能性のある Fragment Shader 問題

#### 可能性1: テクスチャレイヤーインデックスの問題

Fragment Shaderは `in.texCoord.z` を使ってテクスチャレイヤーを選択：
```metal
float4 texColor = tex.sample(sam, in.texCoord.xy, uint(in.texCoord.z));
```

**問題の可能性**:
- グリフアトラスと通常テクスチャが混在
- レイヤーインデックスが間違っている場合、違うテクスチャをサンプリング

**検証方法**: VERTEX-ADDログでtexCoord.zを確認（すでに収集済み）

#### 可能性2: UV座標範囲の問題

アトラスは512x512だが、グリフは小さい（例: 16x24ピクセル）。

**問題の可能性**:
- UV座標が[0,1]範囲を超えている
- テクスチャサンプラーの wrap モードが間違っている（clamp vs repeat）

**検証方法**: V3ログでUV範囲を確認（u0, v0, u1, v1が[0,1]内か）

#### 可能性3: アルファブレンディングの問題

Fragment Shaderは以下を実行：
```metal
float4 texColor = tex.sample(sam, in.texCoord.xy, uint(in.texCoord.z));
return texColor * in.color;
```

**問題の可能性**:
- `in.color` のアルファが0になっている
- ブレンディングモードが間違っている

**検証方法**: 頂点カラーをログ出力（VERTEX-ADDに追加）

#### 可能性4: テクスチャアレイバインディングの問題

Metal Shaderは `texture2d_array<float>` を使用。

**問題の可能性**:
- グリフアトラステクスチャがアレイの正しいインデックスにバインドされていない
- 更新後のテクスチャがGPUに正しく送信されていない

**検証方法**: metal_backend.mm でテクスチャバインディングを確認

---

## V4 調査プラン

### 戦略: Fragment Shader デバッグ出力

Fragment Shaderにデバッグ出力を追加し、何が起きているか可視化する。

**アプローチ**:
1. Fragment Shaderを一時的に修正し、テクスチャサンプリング結果を可視化
2. 各段階の中間結果を色として出力
3. 視覚的に何が起きているか確認

### ステップ1: テクスチャサンプリング結果の可視化

**修正箇所**: `simplegraphic/src/backend/metal/Shaders.metal` (Fragment Shader)

**現在のコード**:
```metal
fragment float4 fragment_main(VertexOut in [[stage_in]],
                               texture2d_array<float> tex [[texture(0)]],
                               sampler sam [[sampler(0)]])
{
    float4 texColor = tex.sample(sam, in.texCoord.xy, uint(in.texCoord.z));
    return texColor * in.color;
}
```

**デバッグ修正A: テクスチャサンプリングを可視化**:
```metal
fragment float4 fragment_main(VertexOut in [[stage_in]],
                               texture2d_array<float> tex [[texture(0)]],
                               sampler sam [[sampler(0)]])
{
    float4 texColor = tex.sample(sam, in.texCoord.xy, uint(in.texCoord.z));

    // DEBUG: テクスチャアルファが0なら赤、0でないなら緑で表示
    if (texColor.a < 0.01) {
        return float4(1.0, 0.0, 0.0, 1.0);  // 赤 = テクスチャアルファ0
    } else {
        return float4(0.0, 1.0, 0.0, texColor.a);  // 緑 = テクスチャアルファあり
    }
}
```

**期待される結果**:
- テキストグリフ部分が緑に表示 → テクスチャサンプリング成功
- テキストグリフ部分が赤に表示 → テクスチャサンプリング失敗（アルファ0）

---

### ステップ2: UV座標の可視化

**デバッグ修正B: UV座標を色として出力**:
```metal
fragment float4 fragment_main(VertexOut in [[stage_in]],
                               texture2d_array<float> tex [[texture(0)]],
                               sampler sam [[sampler(0)]])
{
    // DEBUG: UV座標を可視化
    // U座標 = 赤チャンネル、V座標 = 緑チャンネル
    return float4(in.texCoord.x, in.texCoord.y, 0.0, 1.0);
}
```

**期待される結果**:
- テキストグリフが異なる色で表示される（UV座標が正しく渡されている）
- すべて同じ色 → UV座標が正しく計算されていない

---

### ステップ3: テクスチャレイヤーインデックスの可視化

**デバッグ修正C: テクスチャレイヤーを色として出力**:
```metal
fragment float4 fragment_main(VertexOut in [[stage_in]],
                               texture2d_array<float> tex [[texture(0)]],
                               sampler sam [[sampler(0)]])
{
    // DEBUG: テクスチャレイヤーインデックスを可視化
    uint layer = uint(in.texCoord.z);
    if (layer == 0) return float4(1.0, 0.0, 0.0, 1.0);  // 赤 = レイヤー0
    if (layer == 1) return float4(0.0, 1.0, 0.0, 1.0);  // 緑 = レイヤー1
    if (layer == 2) return float4(0.0, 0.0, 1.0, 1.0);  // 青 = レイヤー2
    return float4(1.0, 1.0, 1.0, 1.0);  // 白 = その他
}
```

**期待される結果**:
- グリフアトラスが特定の色（例: 赤）
- 通常画像が別の色（例: 緑）
- 混在していれば、レイヤー割り当てが正しい
- すべて同じ色なら、レイヤーインデックスが間違っている

---

### ステップ4: 頂点カラーの可視化

**デバッグ修正D: 頂点カラーをそのまま出力**:
```metal
fragment float4 fragment_main(VertexOut in [[stage_in]],
                               texture2d_array<float> tex [[texture(0)]],
                               sampler sam [[sampler(0)]])
{
    // DEBUG: 頂点カラーをそのまま出力
    return in.color;
}
```

**期待される結果**:
- テキストが指定された色（白、黄、緑）で表示される → 頂点カラー正常
- すべて黒または透明 → 頂点カラーが間違っている

---

## 実装プラン

### Phase A: デバッグ修正A（テクスチャアルファ可視化）

**タスク割り当て**:
- **Artisan**: Shaders.metal を修正A で変更、ビルド、デプロイ
- **Paladin**: visual_test.lua 実行、スクリーンショット撮影、結果確認

**タイムボックス**: 15分

**成功基準**:
- ✅ テキスト部分が緑に表示 → テクスチャサンプリング成功
- ❌ テキスト部分が赤に表示 → テクスチャサンプリング失敗（次の修正へ）

---

### Phase B: 結果に基づいた次の修正（条件分岐）

#### ケースA: テクスチャアルファ = 0（赤表示）

**問題**: テクスチャサンプリングは成功しているが、アルファが0

**次の調査**:
- テクスチャ更新が正しく行われているか確認（metal_backend.mmのupdate_texture呼び出し）
- テクスチャレイヤーインデックスが正しいか確認（修正C実行）

#### ケースB: テクスチャアルファ > 0（緑表示）

**問題**: テクスチャサンプリング成功、アルファも正常

**次の調査**:
- 頂点カラーが正しいか確認（修正D実行）
- ブレンディングモードが正しいか確認

#### ケースC: 一部が緑、一部が赤

**問題**: 一部のグリフのみテクスチャサンプリング成功

**次の調査**:
- なぜ一部だけ成功するのか（UV座標確認、修正B実行）
- テクスチャアトラスのどの部分が正しくサンプリングされているか

---

## タイムライン

- Phase A: デバッグ修正A実装・テスト（15分）
- Phase B: 結果分析・次の修正（10分）
- Phase C: 追加デバッグ修正（必要に応じて、15分）
- Phase D: 根本原因特定・修正案立案（10分）
- **合計: 約50分**（タイムボックス: 最大1時間）

---

## リスク評価

### リスク1: Fragment Shader デバッグ修正が視覚的結果を変えすぎる

**影響**: MEDIUM
- デバッグ出力により、元の問題が見えなくなる可能性

**対策**:
- 各デバッグ修正後、元のシェーダーに戻す
- スクリーンショットを各段階で撮影

**ロールバック**: 元のShaders.metalをgitで復元

---

### リスク2: Fragment Shader以外が問題の場合

**影響**: LOW
- V1/V2/V3で他のレイヤーは検証済み
- Fragment Shaderが唯一の未検証コンポーネント

**対策**:
- Phase Aで緑表示（テクスチャサンプリング成功）の場合、頂点カラーやブレンディングを調査
- 1時間で原因特定できない場合、ユーザーに状況報告

---

### リスク3: 問題が複合的な場合

**影響**: MEDIUM
- 複数の小さな問題が重なっている可能性

**対策**:
- 各デバッグ修正で1つずつ検証
- すべての中間結果をスクリーンショットで記録
- 問題が複数ある場合、優先順位をつけて1つずつ解決

---

## 成功基準

### 調査成功基準

1. ✅ Fragment Shaderのどのステップで問題が発生しているか特定
2. ✅ テクスチャサンプリング、UV座標、レイヤーインデックス、頂点カラーのいずれかが原因と確定
3. ✅ 根本原因に基づいた修正案を立案

### 最終成功基準（V4完了後）

1. ✅ すべてのテキストが正しく表示される
2. ✅ すべてのテキストが正しい色で表示される
3. ✅ 画像（ring.png）が正しく表示される
4. ✅ スクリーンショットでユーザー確認済み

---

## CRITICAL LESSONS の適用

### ルール1: ログは参考、視覚的結果が真実

**適用**:
- 各デバッグ修正後、必ずスクリーンショット撮影
- 色の変化を視覚的に確認
- ログ出力ではなく、画面表示で判断

### ルール2: すべての実装後15分以内に視覚的検証

**適用**:
- Phase A完了後、即座にvisual_test.lua実行
- 15分以内にスクリーンショット確認
- 結果に基づいて次のフェーズに進む

### ルール5: 視覚的変化がなければ「失敗」と認める

**適用**:
- デバッグ修正Aで緑/赤の変化が見られない場合、即座に「失敗」と認める
- 別のアプローチを試みる
- ユーザーに状況報告

---

**状態**: Phase 3 完了 - Phase 4（レビュー）に進む
