# 学習記録: テクスチャフォーマット修正時のグリフアトラス問題

**日付**: 2026-02-01 23:59
**記録者**: Prophet
**重要度**: HIGH
**カテゴリ**: 失敗パターン

## 状況

TEXTURE_FORMAT_FIX_PLAN_2026-02-01.mdを実装中、「RGBAテクスチャはR8データと後方互換性がある」という前提が誤りであることが判明。グリフアトラス生成時にセグメンテーションフォルトが発生。

## 原因

**誤った仮定:**
- 「RGBA形式のテクスチャを作成すれば、R8データもRGBAデータも両方アップロードできる」
- 実際: データサイズが一致しないためメモリアクセス違反

**技術的詳細:**
1. グリフアトラス生成（sg_text.cpp）: R8データ（1バイト/ピクセル）= 1,048,576バイト
2. テクスチャ作成（metal_backend.mm）: RGBA形式（4バイト/ピクセル期待）= 4,194,304バイト
3. データアップロード: `replaceRegion:withBytes:bytesPerRow:bytesPerImage:`
   - bytesPerRow = width × 4 = 4096バイト
   - 実際のデータ: 1,048,576バイト
   - → メモリ範囲外アクセス → Segmentation Fault (Exit code 139)

## 学習

### ❌ 誤ったアプローチ

1. **仮定のみで計画を承認**
   - 「後方互換性がある」という仮定を検証せずに計画承認
   - プロトタイプやテストなしに実装開始

2. **データレイアウトの理解不足**
   - テクスチャフォーマット（Metal API）とデータ構造（C++）の違いを理解していなかった
   - 「フォーマット」はメタデータではなく、実際のバイト配置を規定する

### ✅ 正しいアプローチ

1. **仮定は小規模テストで検証**
   - 計画段階で「R8→RGBA互換性」をテストすべきだった
   - 5分のプロトタイプで発見できた問題

2. **データフロー全体を追跡**
   - データ生成（sg_text.cpp）
   - データ転送（metal_backend.mm）
   - GPU消費（シェーダー）
   - 全段階でフォーマット一貫性を確認

3. **クラッシュログの即座確認**
   - Exit code 139 = Segmentation Fault = メモリアクセス違反
   - → データサイズ/ポインタ問題を疑う

## 解決策

### Option A: フォーマットパラメータ追加（技術的に正しい）
```cpp
void* create_texture(int width, int height, const uint8_t* data, TextureFormat format);
```
- 明示的なフォーマット指定
- 各呼び出し元が責任を持つ
- メモリ無駄なし

### Option B: グリフアトラスRGBA変換（迅速）
```cpp
// sg_text.cpp でR8→RGBA変換
for (int i = 0; i < width * height; i++) {
    rgba[i*4+0] = r8[i];  // R
    rgba[i*4+1] = r8[i];  // G
    rgba[i*4+2] = r8[i];  // B
    rgba[i*4+3] = 255;    // A
}
```
- 単一ファイル変更
- 15分で完了
- メモリ4倍（許容範囲）

## 推奨

**Option B**を推奨:
1. プロトタイプ段階ではメモリオーバーヘッド許容可能
2. 視覚的検証を最優先（CRITICAL_FAILURE_ANALYSIS.mdの教訓）
3. 迅速な実装→テスト→検証のサイクル

## 予防策

1. **仮定は必ず検証**
   - 「互換性がある」「動くはず」→ 小規模テストで確認
   - 5分のテストで数時間の手戻りを防ぐ

2. **データフロー図を描く**
   - 生成→転送→消費の全段階を明示
   - フォーマット/サイズ/レイアウトを各段階で記載

3. **クラッシュは即座に調査**
   - Exit code 139/11 = メモリ問題
   - → データサイズ、ポインタ、境界チェック

## 適用

次回、テクスチャやバッファを扱う際:
- [ ] データ生成側のフォーマットを確認
- [ ] データ転送側の期待フォーマットを確認
- [ ] 不一致があれば変換または明示的指定
- [ ] 小規模テストで検証してから本実装

## ステータス

**現在**: Option AとBを提示、ユーザー判断待ち
**次回**: 選択された解決策を実装→視覚的検証
