# シェーダー分析計画 - 黄色テキスト出力調査

**日付**: 2026-02-04
**Prophet**: Task 1 - シェーダー分析
**状態**: Phase 3 - 計画立案完了

---

## エグゼクティブサマリー

**目的**: pob2macosプロジェクトで黄色（RGB ~1,1,0）テキストが表示される問題を調査し、シェーダーレベルで原因を特定する

**背景**:
- 現在のテキストレンダリングで黄色が出力されている
- 過去の調査（YELLOW_TEXT_INVESTIGATION_PLAN_2026-02-02.md）でvisual_test.luaがSetDrawColor(1.0, 1.0, 0.0, 1.0)を明示的に指定していることを確認
- しかし、シェーダーレベルでどのように色が出力されているか不明

**根本目標**: シェーダーコード内で黄色（RGB ~1,1,0）を生成する可能性のあるすべてのコードパスを特定

**推定作業時間**: 20分（調査15分、報告5分）

---

## 根本原因分析（Root Cause Analysis）

### 現在の状況

**既知の事実**:
1. visual_test.luaでSetDrawColor(1.0, 1.0, 0.0, 1.0)を指定（Lua層）
2. 実際に黄色テキストが画面に表示される（視覚的確認済み）
3. 過去にDebug Mod A/B/Cを実装したが、現在のシェーダー状態は不明

**調査が必要な範囲**:
- Metal shaderのfragment関数内での色計算
- 頂点カラーとテクスチャカラーのブレンディング
- デバッグコードの残存有無
- デフォルト色の設定

### 仮説

**仮説1: 頂点カラー乗算が正常に動作**
- Lua層のSetDrawColor(yellow) → 頂点カラーとしてGPUに送信 → フラグメントシェーダーで乗算
- **可能性**: HIGH（最もシンプルな説明）
- **証拠**: 黄色が意図通り表示されている

**仮説2: デバッグコードの残存**
- 過去のDebug Mod A/B/Cが部分的に残っている
- **可能性**: MEDIUM
- **証拠**: 過去に複数回のシェーダー修正履歴あり

**仮説3: 色変換ロジックの存在**
- RGB値の変換やクランプが発生している
- **可能性**: LOW
- **証拠**: 意図的な変換ロジックを実装した記録なし

---

## 調査計画（Phase: Shader Analysis）

### 目標

1. すべての.metalおよび.mmファイルで色関連コードを特定
2. 黄色（RGB ~1,1,0）を生成する可能性のあるコードパスをリスト化
3. フラグメントシェーダーの現在の実装を確認
4. デバッグコードの残存有無を確認
5. 結果を構造化されたレポートとして出力

### Step 1: 色関連コードの網羅的検索（5分）

**実行者**: Sage

**タスク**:
```bash
# simplegraphicディレクトリ内のすべての.metalおよび.mmファイルを検索
cd /Users/kokage/national-operations/pob2macos/dev/simplegraphic/src/backend/metal

# キーワード検索
# 1. "color", "rgb", "rgba"
# 2. "float3", "float4", "vec3", "vec4"
# 3. "1.0.*1.0.*0" (黄色パターン)
# 4. "fragment" (フラグメント関数)
# 5. "texColor" (テクスチャサンプリング)
```

**期待結果**:
- metal_backend.mmのフラグメント関数（fragment_main）
- 色計算関連のC++コード（もしあれば）
- デバッグコードの残存（Debug Mod A/B/C）
- その他の色出力コード

**成功基準**:
- すべての.metal/.mmファイルを検索完了
- 色関連コードのリストを作成

---

### Step 2: フラグメントシェーダーの詳細分析（5分）

**実行者**: Sage

**タスク**: metal_backend.mmのfragment_main関数を精読

**確認事項**:
1. **入力**:
   - in.color（頂点カラー）
   - in.texCoord（テクスチャ座標）
   - tex（テクスチャ）

2. **処理**:
   - テクスチャサンプリング方法
   - 頂点カラーとテクスチャカラーのブレンディング
   - デバッグコードの有無

3. **出力**:
   - return文の構造
   - 色の計算式

**分析フォーマット**:
```markdown
### Fragment Shader Analysis

**File**: metal_backend.mm
**Lines**: XXX-YYY

**Input**:
- in.color: [説明]
- in.texCoord: [説明]
- tex: [説明]

**Processing**:
[コードスニペット]

**Output**:
[return文の分析]

**Yellow Generation Possibility**:
- [このコードが黄色を生成する可能性の説明]
```

---

### Step 3: 黄色生成コードパスの特定（3分）

**実行者**: Sage

**タスク**: Step 1-2の結果から、黄色（RGB ~1,1,0）を生成する可能性のあるコードパスをすべてリスト化

**分析観点**:
1. **直接的な黄色生成**:
   - `float4(1.0, 1.0, 0.0, 1.0)` のようなリテラル
   - `float4(1.0, 1.0, 0.0, alpha)` のようなパターン

2. **間接的な黄色生成**:
   - `texColor * in.color` で in.color が黄色の場合
   - `float4(in.color.rgb, 1.0)` でin.colorが黄色の場合

3. **条件分岐による黄色生成**:
   - if文でRGB(1,1,0)を返すケース

**出力フォーマット**:
```markdown
## 黄色生成コードパス

### パス1: [説明]
**ファイル**: `path/to/file.metal`
**行番号**: XXX
**コード**:
\`\`\`metal
[コードスニペット]
\`\`\`
**分析**: [なぜこれが黄色を生成するか]
**可能性**: HIGH/MEDIUM/LOW

### パス2: ...
```

---

### Step 4: デバッグコードの確認（2分）

**実行者**: Sage

**タスク**: 過去のDebug Mod A/B/Cの残存を確認

**確認内容**:
- Debug Mod A: `if (texColor.a < 0.01) return RED; else return GREEN;`
- Debug Mod B: `return float4(1.0, 0.0, 1.0, 1.0);` (マゼンタ)
- Debug Mod C: `return texColor;` (生のテクスチャ色)

**判定**:
- デバッグコード残存 → V6のクリーンビルドが不完全
- デバッグコードなし → 正常な実装に戻っている

---

### Step 5: レポート作成（5分）

**実行者**: Sage

**タスク**: 調査結果を構造化されたMarkdownレポートとして作成

**レポートパス**: `/Users/kokage/national-operations/.claude/debug_reports/task_1_shader_analysis.md`

**必須セクション**:
1. **概要**: 調査目的と方法
2. **発見された色出力コード**: すべての色関連コード（ファイル名、行番号、コードスニペット、分析）
3. **黄色生成コードパス**: 黄色を生成する可能性のあるコードパスのリスト
4. **デバッグコード確認結果**: Debug Mod A/B/Cの残存有無
5. **結論**: 最も疑わしいコードパスと推奨される次のステップ

---

## エージェント割り振り

### Sage（技術調査）

**タスク**:
1. Step 1: 色関連コードの網羅的検索（5分）
2. Step 2: フラグメントシェーダーの詳細分析（5分）
3. Step 3: 黄色生成コードパスの特定（3分）
4. Step 4: デバッグコードの確認（2分）
5. Step 5: レポート作成（5分）

**成功基準**:
- すべてのStepを完了
- `.claude/debug_reports/task_1_shader_analysis.md` を作成
- 黄色生成コードパスを明確に特定
- 次のステップを推奨

**推定時間**: 20分

**出力形式**: Markdown形式のレポート

---

## タイムライン

- Step 1: 色関連コード検索（5分）
- Step 2: フラグメントシェーダー分析（5分）
- Step 3: 黄色生成コードパス特定（3分）
- Step 4: デバッグコード確認（2分）
- Step 5: レポート作成（5分）
- **合計: 20分**

---

## リスク評価

### リスク1: シェーダーコードが複雑すぎる

**影響**: MEDIUM
**確率**: LOW
**対策**: 段階的に分析、必要に応じてコメント追加

### リスク2: デバッグコードが複数箇所に分散

**影響**: MEDIUM
**確率**: MEDIUM
**対策**: 全ファイルを網羅的に検索

### リスク3: 黄色生成原因が特定できない

**影響**: LOW
**確率**: LOW（既存の情報から原因はほぼ明確）
**対策**: 仮説1-3を順番に検証

---

## 成功基準

### 調査成功基準

1. ✅ すべての.metal/.mmファイルを検索完了
2. ✅ フラグメントシェーダーの現在の実装を確認
3. ✅ 黄色生成コードパスを特定（最低1つ）
4. ✅ デバッグコードの残存有無を確認
5. ✅ レポートを`.claude/debug_reports/task_1_shader_analysis.md`に保存

### レポート品質基準

1. ✅ すべての発見に対してファイルパス・行番号・コードスニペットを記載
2. ✅ 各コードパスに対して「なぜ黄色を生成するか」の説明を記載
3. ✅ 可能性（HIGH/MEDIUM/LOW）を評価
4. ✅ 次のステップを明確に推奨

---

## CRITICAL LESSONS の適用

### ルール1: ログは参考、視覚的結果が真実

**適用**:
- 視覚的結果（黄色テキスト表示）を調査の起点とする
- シェーダーコードの実際の実装を確認（ビルドログではなく）

### ルール2: 15分以内の時間制限

**適用**:
- 調査タイムライン: 20分（調査15分、レポート5分）
- 時間超過した場合は中間報告

### ルール3: Occam's Razor - 最もシンプルな説明

**適用**:
- 仮説1（頂点カラー乗算）を最優先で検証
- 複雑な理論（仮説3）は最後に検証

### ルール4: 階層構造の厳守

**適用**:
- Prophet は調査を実行しない ✅
- Sage に技術調査を完全に委譲 ✅
- Mayor は不要（低リスク調査タスク）

### Learning Protocol

**適用**:
- 調査結果を LESSONS_LEARNED.md に記録（必要な場合）
- 新しいパターンがあれば追加

---

## 次ステップの条件分岐

### ケースA: 頂点カラー乗算が正常に動作

**発見**: `return texColor * in.color;` のような実装

**結論**: 黄色はLua層のSetDrawColor()で設定された意図的な色

**次ステップ**:
- 問題なし、調査完了
- ユーザーに報告（黄色は意図的な設定）

---

### ケースB: デバッグコードが残存

**発見**: Debug Mod A/B/Cのコードが残っている

**結論**: V6のクリーンビルドが不完全

**次ステップ**:
- デバッグコードを除去
- クリーンビルド + デプロイ
- 視覚的検証

---

### ケースC: 不明な色変換ロジック

**発見**: 予期しない色計算やクランプが存在

**結論**: 追加の調査が必要

**次ステップ**:
- Prophetにエスカレーション
- 新しい計画を立案

---

**計画書ステータス**: Phase 3 完了 - Phase 4（レビュー）に進む
