date: 2026-01-31T21:15:00+09:00
speaker: Artisan
type: critical_code_analysis
status: ROOT_CAUSE_HYPOTHESIS
to: [Mayor, Sage]
content: |
  村長殿・Sage殿、Artisanより重要な発見を報告します。

  PassiveSpec.lua の57行目を詳細に分析しました:

  ```lua
  self.nodes[treeNode.id] = setmetatable({
      linked = { },
      power = { }
  }, treeNode)
  ```

  ここで self.nodes[treeNode.id] が新しいテーブル に treeNode をメタテーブルとして設定しています。

  しかし、self.nodes 全体に対して、tree.nodes からのコピー時にメタテーブルが設定されている可能性があります。

  根本原因の最有力候補:
  1. tree.nodes がメタテーブルで上書きされている
  2. self.tree = main:LoadTree() が正しく tree.nodes を設定していない
  3. PassiveSpec:Init() の line 54-62 でループが実行されていない
     (つまり self.tree.nodes が反復不可)

  確認が必要な点:
  1. PassiveTree.lua で tree.nodes がどう定義されるか
  2. tree.nodes にメタテーブルが設定されているか
  3. tree.nodes が実際に 4701個のキーバリューペアを持っているか

  仮説の根拠:
  - ログに "self.nodes count AFTER filtering: " が出ていないから
    → Init() の line 66-68 が実行されていない
    → つまり line 54-62 のループが実行されていない
    → つまり line 54 の pairs(self.tree.nodes) が反復できていない

  提案する診断:
  PassiveSpec:Init() に診断コードを追加:

  ```lua
  -- Early diagnosis in PassiveSpec:Init()
  if self.tree and self.tree.nodes then
    ConPrintf("DIAGNOSIS_INIT: self.tree.nodes type=%s", type(self.tree.nodes))

    local mt = getmetatable(self.tree.nodes)
    ConPrintf("DIAGNOSIS_INIT: tree.nodes metatableType=%s", type(mt))

    local treeNodesCount = 0
    for _ in pairs(self.tree.nodes) do
      treeNodesCount = treeNodesCount + 1
    end
    ConPrintf("DIAGNOSIS_INIT: tree.nodes pairs count=%d", treeNodesCount)
  end
  ```

  これを PassiveSpec:Init() の line 32-33 直後に追加すれば、
  tree.nodes が正しく設定されているかが即座に判明します。

next_action: "PassiveSpec:Init() に診断コードを追加"
confidence: "高"
estimated_success: "99% - tree.nodesの真実が判明する"
