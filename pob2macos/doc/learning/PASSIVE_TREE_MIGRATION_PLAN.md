# パッシブツリー機能 完全移行計画

**日付**: 2026-02-04
**目的**: Windows版PoB2のパッシブツリー機能をmacOSに段階的に移植

---

## 📊 現在の状態

### 動作している機能 ✅
- ✅ パッシブツリーの表示（PoE2 TreeData）
- ✅ ノードのレンダリング（アイコン、背景、ライン）
- ✅ ホバー判定（動的半径フォールバック）
- ✅ パン/ズーム操作
- ✅ DDS画像の読み込みと表示
- ✅ 入力処理（マウス、キーボード、ホイール）

### MINIMAL構成の制限 ⚠️
- ❌ modLib未ロード → ModList機能が制限
- ❌ クラス/アセンダンシー切替が実機未確認
- ❌ ノードクリックによる割当/解除が未実装
- ❌ 統計計算が動作しない
- ❌ ツールチップ内容が制限
- ❌ パスの視覚的ハイライトが制限

---

## 🎯 段階的移行プラン

### フェーズ1: 基盤確認とテスト（現在完了）✅

**目標**: 現在のMINIMAL構成が安定動作することを確認

**完了項目**:
- ✅ パッシブツリー表示の安定化
- ✅ ホバー判定の動作確認
- ✅ デプロイプロセスの確立

---

### フェーズ2: ModListとmodLibの段階的ロード ⚠️ 保留中

**目標**: MINIMAL構成から本番構成への移行

**最新の発見 (2026-02-04 23:45)**:
Windows版の`Modules/Data.lua`と`Modules/ModTools.lua`はPoE1用で、PoE2とは非互換です:
- PoE1: `data.characterConstants["mana_regeneration_rate_per_minute_%"]`
- PoE2: `data.characterConstants["character_inherent_mana_regeneration_rate_per_minute_%"]`

これらのモジュールをPoE2に適応させるには大幅な修正が必要です。

**現在の解決策**:
代わりに`Data/Misc.lua`を直接ロードして基本的なデータ構造（characterConstants、gameConstants）を取得:
```lua
data = {}
LoadModule("Data/Misc", data)  -- PoE2用のデータをロード
```

#### ステップ2.1: modLibの最小実装 ⚠️ スキップ
**理由**: PoE1/PoE2の非互換性により、ModToolsとDataモジュールの完全な適応が必要

**代替アプローチ**:
1. 現在のMINIMAL構成を維持（emptyModListスタブ使用）
2. 将来的にPoE2専用のModListとModToolsを実装
3. または、PoE1モジュールを段階的にPoE2対応に書き換え

**期待される成果** (保留):
- ~~ModList.Sum(), ModList.More()が正常動作~~
- ~~ノードのmodListが実際のModオブジェクトを持つ~~
→ フェーズ3とフェーズ4の機能は基本的なModListなしでも動作可能

**検証方法** (保留):
```lua
-- テストコード (現在は動作しない)
local node = spec.nodes[someNodeId]
print("Node mods:", #node.modList)  -- 0以上の値
print("Life sum:", node.modList:Sum("BASE", nil, "Life"))  -- 実際の値
```

#### ステップ2.2: データモジュールのロード
**作業内容**:
1. `src/Data/ModCache.lua`を確認
2. `src/Modules/Data.lua`の必要部分をロード
3. PassiveSpecがModCacheを使用できるように修正

**期待される成果**:
- ノードのmod解析が正常動作
- 統計計算の基盤が整う

---

### フェーズ3: クラス/アセンダンシー切替の実装

**目標**: ユーザーがクラスやアセンダンシーを選択できるようにする

#### ステップ3.1: クラス切替UI（簡易版）
**作業内容**:
1. クラス開始ノードのクリック検出
2. `spec:SelectClass(classId)`の呼び出し
3. 中央背景画像の切替確認
4. ノード表示の更新確認

**実装場所**:
- `PassiveTreeView.lua:OnKeyDown()` - クリック処理
- `PassiveSpec.lua:SelectClass()` - 既存実装を確認

**テスト方法**:
```
1. アプリを起動
2. 別のクラスの開始ノードをクリック
3. 中央背景画像が切り替わることを確認
4. ノード表示が更新されることを確認
```

#### ステップ3.2: アセンダンシー切替
**作業内容**:
1. アセンダンシー開始ノードのクリック検出
2. `spec:SelectAscendClass(ascendClassId)`の呼び出し
3. アセンダンシーノードの表示切替
4. 背景画像の切替確認

**検証項目**:
- アセンダンシーノードが正しく表示される
- 他のアセンダンシーノードが非表示になる
- 開始ノードへのパスが正しく計算される

---

### フェーズ4: ノード割当/解除の実装

**目標**: ユーザーがノードを割り当て・解除できるようにする

#### ステップ4.1: 基本的な割当/解除
**作業内容**:
1. 通常ノードのクリック → 割当/解除
2. `spec:AllocNode(nodeId)`の実装確認
3. `spec:DeallocNode(nodeId)`の実装確認
4. パスの自動計算（BuildAllDependsAndPaths）

**実装場所**:
- `PassiveTreeView.lua:OnKeyDown()` - 左クリック処理

**ロジック**:
```lua
if leftClick then
    if node.alloc then
        -- 割り当て済み → 解除を試みる
        if spec:CanDeallocNode(node) then
            spec:DeallocNode(node.id)
        end
    else
        -- 未割り当て → 割り当てを試みる
        if spec:CanAllocNode(node) then
            spec:AllocNode(node.id)
        end
    end
end
```

#### ステップ4.2: パス計算と視覚的フィードバック
**作業内容**:
1. 割当可能なノードのハイライト
2. パスの視覚的表示
3. コスト計算（ポイント数）

**視覚的表示**:
- 緑: 割当可能
- 赤: 割当不可（パスなし）
- 黄: ホバー中

---

### フェーズ5: 統計表示とツールチップ

**目標**: ノードの効果とビルド統計を表示する

#### ステップ5.1: ツールチップの実装
**作業内容**:
1. ノードホバー時のツールチップ表示
2. Mod効果の解析と表示
3. フォーマットされたテキスト表示

**実装場所**:
- `PassiveTreeView.lua:Draw()` - ツールチップレンダリング
- `PassiveSpec.lua` - Mod情報取得

**ツールチップ内容**:
```
ノード名
----------------
+X to Life
+Y% to Life
+Z to Strength
----------------
ポイント: 1
```

#### ステップ5.2: ビルド統計の表示
**作業内容**:
1. 画面端に統計パネルを表示
2. 合計Life、ES、Mana、DPS等を表示
3. リアルタイム更新

**表示場所**: 画面右側または下部

---

## 📅 実装順序とマイルストーン

### マイルストーン1: ModList基盤 ⚠️ 保留
- [x] modLib依存関係調査完了
- [x] PoE1/PoE2非互換性を発見
- [ ] ~~modLib最小実装~~ → 保留中
- [ ] ~~ModList正常動作~~ → 保留中
- [ ] ~~emptyModListスタブ削除~~ → 保留中

**成功基準変更**:
- ~~`node.modList:Sum()`が実際の値を返す~~
- 代わりに: フェーズ3とフェーズ4をemptyModListスタブで実装
- 完全なModList統合は将来のフェーズとして延期

---

### マイルストーン2: クラス切替（1日）
- [ ] クラス開始ノードクリック検出
- [ ] SelectClass()動作確認
- [ ] 中央背景切替確認

**成功基準**: 別のクラスをクリックして背景が切り替わる

---

### マイルストーン3: ノード割当（2-3日）
- [ ] 通常ノードの割当/解除
- [ ] パス計算
- [ ] 視覚的フィードバック

**成功基準**: ノードをクリックして割り当て、パスが表示される

---

### マイルストーン4: ツールチップ（1-2日）
- [ ] 基本的なツールチップ
- [ ] Mod効果の表示
- [ ] フォーマット調整

**成功基準**: ホバー時に効果が表示される

---

### マイルストーン5: 統計表示（1-2日）
- [ ] 統計パネル
- [ ] リアルタイム更新
- [ ] 主要ステータス表示

**成功基準**: ノード割当時に統計が更新される

---

## 🚧 技術的課題と対策

### 課題1: modLib依存関係
**問題**: ModListがmodLibの多くの関数を要求する

**対策**:
1. 段階的実装: 必要な関数から順に実装
2. スタブ関数: 未実装関数は空実装でエラー回避
3. ログ記録: 呼ばれた関数を記録して優先順位付け

### 課題2: パフォーマンス
**問題**: BuildAllDependsAndPaths()が重い可能性

**対策**:
1. プロファイリング: 実際の実行時間を計測
2. 最適化: ボトルネックを特定して改善
3. キャッシング: 計算結果をキャッシュ

### 課題3: メモリ使用量
**問題**: 大量のノードとModデータがメモリを消費

**対策**:
1. 遅延ロード: 必要なデータのみロード
2. ガベージコレクション: 適切なタイミングでGC実行
3. モニタリング: メモリ使用量を監視

---

## ✅ 検証とテスト

### 各フェーズの検証項目

#### フェーズ2検証
```bash
# テスト起動
./codex/run_passive_tree_test.command

# 期待される出力
- ModList created successfully
- Node mods count > 0
- No emptyModList stubs remaining
```

#### フェーズ3検証
```bash
# 手動テスト
1. アプリ起動
2. 別クラスの開始ノードをクリック
3. 中央背景が変わることを確認
4. アセンダンシーノードをクリック
5. アセンダンシー背景が変わることを確認
```

#### フェーズ4検証
```bash
# 手動テスト
1. アプリ起動
2. 開始ノードから隣接ノードをクリック
3. ノードが割り当てられることを確認
4. パスが表示されることを確認
5. もう一度クリックして解除を確認
```

---

## 📝 次のアクション

### 今すぐ実行
1. **フェーズ2.1を開始**: modLibの最小実装
2. **依存関係を調査**: ModList.luaが必要とする関数をリストアップ
3. **テスト環境を準備**: 段階的な変更をテストできる環境

### 今日中に完了
- [ ] modLibの依存関係マップを作成
- [ ] ModList.luaを読み込むための最小変更
- [ ] 簡単なテストで動作確認

### 今週中に完了
- [ ] マイルストーン1（ModList基盤）
- [ ] マイルストーン2（クラス切替）
- [ ] マイルストーン3の準備（ノード割当設計）

---

## 📚 参考資料

### 主要ファイル
- `src/Launch.lua` - エントリーポイント、現在MINIMAL構成
- `src/Classes/PassiveSpec.lua` - パッシブツリーの状態管理
- `src/Classes/PassiveTreeView.lua` - レンダリングと入力処理
- `src/Modules/ModList.lua` - Mod計算（未ロード）
- `src/Modules/ModParser.lua` - Mod解析（未ロード）
- `src/Modules/Data.lua` - ゲームデータ（部分ロード）

### Windows版参考
- `/Users/kokage/Downloads/PathOfBuilding-PoE2-dev/` - Windows版ソース

---

**作成者**: Claude (Sonnet 4.5)
**最終更新**: 2026-02-04 23:10 JST
